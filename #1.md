- int - 4 byte
- char - 1 byte
- float - 4 byte

## Pointers : variables that store the address of another variables
````cpp
int a;
int *p;
p = &a;
a = 5;
printf("%d\n",&a); // 204 (address of a)
printf("%d\n",p); // 204 (address of a stored in pointer p)
printf("%d\n",&p); // 64 (address of pointer p itself)
printf("%d\n",*p); // 5 (value stored in a)
*p = 8;
printf("%d\n",a); // 8 (value stored in a)
````
> `&` means address of 

> Both `*p = 8;` & `printf("%d\n",*p);` are called `dereferencing` which means
> that I want the value which is stored inside the address that is stored inside pointer `p`

<hr>

````cpp
int a; // integer
int *p; // pointer to integer


char c; // character 
char *p1; // pointer to character

double d; // double
double *p1; //pointer to double

````

### Let's play a little with `pointers`
````cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
    int a = 10;
    int *p;
    p = &a;
    printf("Address of a is : %d\n",&a);
    printf("Address of p is : %d\n",p); // same as a
    printf("Value at p is : %d\n",*p); // 10
    int b = 20;
    *p = b;
    printf("Value at p is : %d\n",*p); // 20
}

````


````cpp
int main()
{
    int a = 10;
    int *p;
    p = &a;
    printf("Address of p is : %d\n",p); // address : 200
    printf("Address of p+1 is : %d\n",p+1); // address : 204
}
````
> VIP Note: `p+1` means that I want to increase the address by 1, but since
> this pointer points to an integer then it will increase by 4 bytes (1*4 bytes)
>, that's why we have to specify the data type on which the pointer refers to
> because when the pointer refers to an integer, it then knows that each time i will use `p+1` it will increase by 4 bytes
> not like char data type for example, it will only increase by 1 byte

> The second reason for specify the data type of pointers that it is important in `derefercing`
> , let's assume that `int a` occupies address `200,201,202,203`, then a pointer refering to variable `a`
> will only store first address (`200`), now when I type `printf("%d\n",*p)` this means as we said before
> go to address `200` then print the value stored in it, but in this case the compiler should know the data type of that pointer
> so that if it is an integer for example the compiler will know that from address `200` till `203` (Look at 4 bytes starting from 200) are all reserved for that variable
> so, it is important to know the data type of the pointer to be able to calculate number of reserved bytes for that variable while both reading or writing from that pointer 

- Let's see the following example, to understand it will
````cpp
int main()
{
    int a = 1025;// 00000000 00000000 00000100 00000001
    int *p;
    p = &a;
    printf("Size of integer %d\n", sizeof(int)); // 4
    printf("Address of p : %d , value of p: %d \n",p,*p); // 200 1025
    char *p0;
    p0 = (char *)p;
    printf("Size of character %d\n", sizeof(char)); // 1
    printf("Address of p0 : %d , value of p0: %d \n",p0,*p0); // 200 1
}
````
> As we can see the value of char pointer `p0` is `1`, but why ? <br>
> Let's observe the binary representation of number 125 <br>
> `00000000 00000000 00000100 00000001` when we was printing `*p` it was referring
> to an integer so that the 4 bytes are all related to that variable, 
> but when we cast the int pointer to char one `p0 = (char *)p;` the pointer  `p0` will again store the address
> of the first byte (same as `p`), but in this time it will only print it while dereferining (access/modify) as it is a char pointer (it takes only 1 byte)
> so that its corresponding value now is `00000001`

> Note: the output is a number even when I accessed a char pointer beacuse of `printf("%d")` that prints only numbers

````cpp
int main()
{
    int a = 1025;
    int *p;
    p = &a;
    printf("Address of a %d\n", &a); //200
    printf("Address of p : %d , value of p: %d \n",p+1,*(p+1)); // 204 garbage
    char *p0;
    p0 = (char *)p;
    printf("Size of character %d\n", sizeof(char)); // 1
    printf("Address of c : %d , value of c: %d \n",p0+1,*(p0+1)); // 201 4
}
````
> The value of `*(p0+1)` is `4` because I have moved `1 byte` so now `p0` refers to `00000100` byte the second byte in <br>
> `00000000 00000000 00000100 00000001` 

````cpp 
printf("Size of int %d\n",sizeof(int));
````


````cpp
int main()
{
    int a = 10;
    int *p;
    p = &a;
    printf("Address of p is : %d\n",p); // address : 200
    printf("Address of p+1 is : %d\n",p+1); // address : 204
    printf("Value at p+1 is : %d\n",*(p+1)); // garbage value
}
````